Как работает оркестратор TreatmentProtocolService

Берём уровень боли (VAS) из объекта vas.
Фильтруем протоколы по диапазону боли:
У каждого TreatmentProtocol поле painLevel типа "4-6".
Метод parsePainLevel(...) чистит строку и превращает её в два числа: от и до.
Оставляем те протоколы, где painLevelFrom ≤ VAS ≤ painLevelTo.

Для каждого подходящего протокола создаём черновик рекомендации:
Recommendation со статусом PENDING и приоритетом regimenHierarchy.
Внутрь добавляем две записи препарата: MAIN и ALTERNATIVE (оба — пустые объекты DrugRecommendation).
Им ставится одинаковый путь введения: DrugRoute.valueOf(tp.getRoute()).

Гоним по цепочке всех правил (ruleAppliers, их 9 штук, сортируются по @Order):
Для каждого правила вызываем apply(...) дважды: сперва для mainDrug, потом для altDrug.

Каждое правило может:
заполнить поля препарата (дозу, интервалы и т.п.),
или очистить препарат (или все препараты) — если есть запрет.
После всех правил решаем, добавлять рекомендацию или нет:
Если все препараты “пустые” (см. ниже про clearDrug), то такую рекомендацию мы не добавляем в результирующий список.
Возвращается первая валидная рекомендация (если нужна выдача всех — меняется сигнатура).